---
id: flow-policy
sidebar_label: Flow Policy
title: Flow Policy
abstract: |
  This is a guide to implementing and managing conversational flows using the FlowPolicy.
---

import RasaDiscoveryBanner from "@theme/RasaDiscoveryBanner";
import dialogueStackEvolution from "./dialogue_stack_evolution.png";
import dialogueStackOverview from "./dialogue_stack.png";

<RasaDiscoveryBanner />

Rasa's Flow Policy is a state machine that allows you to manage and control your
chatbot's conversational flows. It facilitates the integration of your business
logic with machine learning capabilities.

The Flow Policy oversees your bot's state, handles state transitions, and
triggers new flows when needed. The "Dialogue Stack" represents all started but
incomplete flows and refers to steps defined in the
[flows specification](../concepts/flows.mdx).

<Image
  img={dialogueStackOverview}
  caption="Dialogue Stack represents the current state of the conversation referring to a flow."
  alt=""
/>

Using the Flow Policy, you can encapsulate your logic into flows, thereby
guiding the conversation based on user input and system response. Other
classifiers adjust the underlying state machine to handle edge cases.

For more detailed information on defining flows, refer to the
[flows specification](../concepts/flows.mdx).

## Adding the FlowPolicy to your bot

The Flow Policy can be integrated like [any other policy](../building-classic-assistants/policies.mdx). It
involves two steps:

1. Configure the `FlowPolicy` in your `config.yml` file:

   ```yaml-rasa title="config.yml"
   policies:
   # - ...
     - name: rasa.core.policies.flow_policy.FlowPolicy
   # - ...
   ```

2. Add flows to your bot as per the [flows specification](../concepts/flows.mdx). This
   step involves defining the states and transitions that your bot should
   recognize and react to.

Once added, the `FlowPolicy` will read all defined flows from your training data
and apply them.

## How does it work?

The `FlowPolicy` employs a dialogue stack structure (Last In First Out) along with
internal slots to manage your bot's state.

### Managing the State

Your bot's state is managed using a "dialogue stack". The dialogue stack stores the
current position in each started flow. The stack follows a "last in, first out"
sequence. The last started flow will be completed first, and then earlier
inserted flows will continue. The dialogue stack is stored in the `dialogue_stack` slot.

Here's an example flow and a conversation currently using it:

```yaml title="flows.yml"
flows:
  transfer_money:
    description: This flow enables users to send money to friends and family.

    steps:
      - id: "ask_recipient"
        collect_information: transfer_money_recipient
        next: "ask_amount"
      - id: "ask_amount"
        collect_information: transfer_money_amount_of_money
        next: "check_transfer_funds"
    # - ...
```

The first step in the flow is `ask_recipient`. A correction by the user, _"oh
sorry I meant John"_, initiates a correction flow. This correction is not
explicitly modeled in the `transfer_money` flow; it's handled by a
conversational pattern:

<Image
  img={dialogueStackEvolution}
  caption="Dialogue stack changes during a correction of a previous user input"
  alt=""
/>

The correction flow only executes when the user wants to correct a previous
input. Once triggered, it's placed on top of the dialogue stack for execution.

For the `transfer_money` flow, the correction flow is an interruption. Once
completed, the `transfer_money` flow resumes. Before its res umption, a
`resume_flow` flow is activated. You can customize what happens in `resume_flow`
and `correction` flows in [Handling Unhappy Paths](./unhappy-paths.mdx).

Upon completion of the `resume_flow` flow, the `transfer_money` flow resumes,
and the bot returns to the state before the correction flow started. The
`transfer_money` flow will re-ask the interrupted question of a
`collect_information` step.

The `resume_flow` and `correction` flows are conversational patterns not
explicitly modeled in the `transfer_money` flow. The `FlowPolicy` automatically
triggers them when needed. For more details on defining conversational patterns,
refer to [Handling Unhappy Paths](./unhappy-paths.mdx).

### Transitioning Between States

The `FlowPolicy` transitions between states either in response to user inputs or
after an action's completion. Initially, it awaits user input. Once received, it
advances the state of the machine until an action prediction is made. After
completing the action and incorporating its result, it moves to the next state.

### Starting New Flows

A flow can be started in several ways:

- A flow is started when a Rasa component puts the flow on the stack. For
  example, the [LLM Command Generator](./llm-command-generator.mdx) puts a flow
  on the stack when it determines that a flow would be a good fit for the
  current conversation.
- One flow can ["link" to another flow](../concepts/flows.mdx#link), which will initiate
  the linked flow and return to the original flow once the linked flow
  completes.
- Flows, which are conversational patterns (e.g. correction, resume flow), are
  automatically initiated by the `FlowPolicy` when needed.

### Interruptions and Digressions

Flows and their specifications should ideally model the happy path of a
conversation. The `FlowPolicy` depends on other components to identify
digressions and interruptions and interrupt the flow accordingly. For details on
which digressions and interruptions the flow policy can handle, refer to
[Handling Unhappy Paths](./unhappy-paths.mdx).

For example, the user message _"oh sorry I meant John"_ is a correction to a
prior input. The `FlowPolicy` depends on another component, like the
[LLM Command Generator](./llm-command-generator.mdx), to identify it as a
correction and set the corresponding slots. Based on this, the `FlowPolicy`
initiates the correction flow.

## Configuration

No additional configuration is required for the FlowPolicy beyond what's already
outlined above.

## FAQs

### Can FlowPolicy be used with other Policies?

Currently, we recommend not using the `FlowPolicy` in conjunction with the
`RulePolicy`. The `RulePolicy` isn't aware of the dialogue stack and may interfere
with the `FlowPolicy`.
